<?xml version="1.0"?>

<document id="howto_ant_cactus">

  <properties>
    <title>Servlet Sample Walkthrough</title>
    <authors>
      <author name="Christopher Lenz" email="cmlenz@apache.org"/>
    </authors>
  </properties>

  <body>

    <section title="Servlet Sample Walkthrough">

      <p>
        Cactus is distributed with a small sample web application, generally
        referred to as the <em>Servlet Sample</em>. You can find this 
        application in the directory <code>samples/servlet</code> in the
        main distribution. While the servlet sample is intended to provide
        insight in how to use Cactus for writing tests, it also nicely
        demonstrates the use of the Ant integration provided by Cactus.
      </p>
      <p>
        In this section, we will walk through the build file of the servlet
        sample step by step, explaining how the Cactus tests are integrated
        into the overall build of the application. I recommended that you look
        at the servlet sample build and play with it after or while reading
        this.
      </p>

      <section title="Starting off with a plain build">

        <p>
          The servlet sample is a simple web application that contains
          a servlet, some JSP tags, a JSP page and a servlet filter. For the
          rest of this document we're going to work with the version of the
          servlet sample for J2EE 1.3.
        </p>
        <p>
          The build file without any Cactus tests is straightforward. As usual,
          the first thing is that a couple of properties are set up:
        </p>

        <source><![CDATA[
<project name="Cactus Servlet Sample" default="dist" basedir=".">

  <property file="build.properties" />
  <property file="${user.home}/build.properties" />

  <property name="project.name.text" value="Cactus Servlet Sample"/>
  <property name="project.name.file" value="sample-servlet"/>
  <property name="project.version" value="@version@"/>

  <property name="project.prefix" value="jakarta-"/>

  <property name="year" value="@year@"/>
  <property name="debug" value="on"/>
  <property name="optimize" value="off"/>
  <property name="deprecation" value="off"/>

  <!-- Directory layout -->
  <property name="src.dir" location="src"/>
  <property name="src.java.dir" location="${src.dir}/java"/>
  <property name="src.webapp.dir" location="${src.dir}/webapp"/>
  <property name="target.dir" location="target"/>
  <property name="target.classes.dir" location="${target.dir}/classes"/>
  <property name="target.classes.java.dir"
      location="${target.classes.dir}/java"/>
  <property name="dist.dir" location="dist"/>

  <!-- Required libraries -->
  <property name="servlet.jar" location="lib/servlet.jar"/>
  <property name="jstl.jar" location="lib/jstl.jar"/>
  <property name="standard.jar" location="lib/standard.jar"/>
  <path id="project.classpath">
    <pathelement location="${servlet.jar}"/>
    <pathelement location="${jstl.jar}"/>
    <pathelement location="${standard.jar}"/>
  </path>
]]></source>

        <p>
          Next, we check whether the required libraries are actually available.
          This is done in the <em>init</em> target. In this case, we just check
          whether the corresponding properties point to existing files.
          Alternatively, we could be checking whether the JARs also contain
          some class we need. We also set the time stamp.
        </p>

        <source><![CDATA[
  <!-- Initialize the build. Must be called by all targets -->
  <target name="init">
    <condition property="properties.ok">
      <and>
        <available file="${servlet.jar}"/>
        <available file="${jstl.jar}"/>
        <available file="${standard.jar}"/>
      </and>
    </condition>
    <fail unless="properties.ok">Missing property...</fail>
    <tstamp/>
  </target>
]]></source>

        <p>
          The first <em>real</em> thing we'll do in the build is to compile
          the application classes.
        </p>

        <source><![CDATA[
  <!-- Compile the Java source -->
  <target name="compile" depends="init"
      description="Compile the application classes">
    <mkdir dir="${target.classes.java.dir}"/>
    <javac destdir="${target.classes.java.dir}"
        debug="${debug}" optimize="${optimize}"
        deprecation="${deprecation}">
      <src path="${src.java.dir}"/>
      <classpath refid="project.classpath"/>
    </javac>
  </target>
]]></source>

        <p>
          What's left is just the generation of the web-application archice
          (WAR) for deployment. We do that using the builtin
          <em>&lt;war&gt;</em> task.
        </p>

        <source><![CDATA[
  <!-- Create the war file -->
  <target name="war" depends="compile"
      description="Generate the runtime war">
    <war warfile="${target.dir}/${project.name.file}.war"
        webxml="${src.webapp.dir}/WEB-INF/web.xml">
      <fileset dir="${src.webapp.dir}"/>
      <classes dir="${target.classes.java.dir}"/>
      <lib file="${jstl.jar}">
      <lib file="${standard.jar}">
    </war>
  </target>
]]></source>

        <p>
          After that, we might want to copy the generated WAR file to the
          distribution directory. In a somewhat more sophisticated application
          we'd also copy things like the API documentation or a user's
          guide to the distribution directory in this target. We also make
          the <em>dist</em> target depend on the <em>clean</em> target, so that
          distribution builds are always a full rebuild.
        </p>

        <source><![CDATA[
  <target name="dist" depends="clean, war"
      description="Generate the distributable files">
    <copy file="${target.dir}/${project.name.file}.war"
        todir="${dist.dir}"/>
  </target>

  <target name="clean"
      description="Remove all generated files">
    <delete dir="${target.dir}"/>
    <delete dir="${dist.dir}"/>
  </target>
]]></source>

      </section>

      <section title="Defining the Cactus Ant tasks">

        <p>
          Now we're ready to start integrating Cactus tests into the build.
          The first thing we need to do for that is to define the Cactus tasks,
          so that they can be used in the build file.
        </p>

        <p>
          The prerequisite for defining the Cactus tasks is to make the Cactus
          JARs accessible to Ant. This can be done in a number of ways, but
          here we're going to assume that they are stored in a <em>lib</em>
          directory of the project. We then define properties representing the
          individual JARs, so that they can be overridden by the user. And we 
          build a reusable classpath using the Ant <em>&lt;path&gt;</em> type.
        </p>

        <source><![CDATA[
  <!-- Libraries required for the Cactus tests -->
  <property name="aspectjrt.jar" location="lib/aspectjrt.jar"/>
  <property name="cactus.jar" location="lib/cactus.jar"/>
  <property name="cactus.ant.jar" location="lib/cactus.ant.jar"/>
  <property name="commons.httpclient.jar"
      location="lib/commons.httpclient.jar"/>
  <property name="commons.logging.jar"
      location="lib/commons.logging.jar"/>
  <property name="httpunit.jar" location="lib/httpunit.jar"/>
  <property name="junit.jar" location="lib/junit.jar"/>
  <property name="nekohtml.jar" location="lib/nekohtml.jar"/>
  <path id="cactus.classpath">
    <path refid="project.classpath"/>
    <pathelement location="${aspectjrt.jar}"/>
    <pathelement location="${cactus.jar}"/>
    <pathelement location="${cactus.ant.jar}"/>
    <pathelement location="${commons.httpclient.jar}"/>
    <pathelement location="${commons.logging.jar}"/>
    <pathelement location="${junit.jar}"/>
  </path>
]]></source>

        <p>
          Once this is done, we can proceed with the actual definition of the
          Cactus tasks, using the Ant <em>&lt;taskdef&gt;</em> task.
        </p>

        <source><![CDATA[
  <taskdef resource="cactus.tasks" classpathref="cactus.classpath"/>
]]></source>

        <p>
          By using the <em>cactus.tasks</em> property file included in the
          <code>cactus-ant.jar</code> library, we can define all Cactus tasks
          in one go, without needing to know the names of the individual task
          classes.
        </p>

      </section>

      <section title="Compiling the Test Code">

        <p>
          Next we need to compile the test case classes. In the servlet sample,
          these are located in the directory <code>src/test-cactus</code>.
          After adding the definition of the two properties
          <em>src.cactus.dir</em> and <em>test.classes.cactus.dir</em> at the
          top of the build file, we can add a target for the test compilation:
        </p>

        <source><![CDATA[
  <!-- Compiles the Cactus test sources -->
  <target name="compile.cactus" depends="compile.java">
    <mkdir dir="${target.classes.cactus.dir}"/>
    <javac destdir="${target.classes.cactus.dir}"
        debug="${debug}" optimize="${optimize}"
        deprecation="${deprecation}">
      <src path="${src.cactus.dir}"/>
      <classpath>
        <path refid="cactus.classpath"/>
        <pathelement location="${httpunit.jar}"/>
        <pathelement location="${nekohtml.jar}"/>
        <pathelement location="${target.classes.java.dir}"/>
      </classpath>
    </javac>
  </target>

  <target name="compile" depends="compile.java, compile.test">
  </target>
]]></source>

        <p>
          Note that we renamed the target to compile the application classes
          from <em>compile</em> to <em>compile.java</em>, and added a wrapper
          target <em>compile</em> that depends on both <em>compile.java</em>
          and <em>compile.test</em>.
        </p>

      </section>

      <section title="Cactifying the Web Application">

        <p>(To be written)</p>

      </section>

      <section title="Running the Cactus Tests">

        <p>(To be written)</p>

      </section>

    </section>

  </body>

</document>
